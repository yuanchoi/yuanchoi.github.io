# 정지문제(Halt Problem)


## 정지문제에 대한 소개

현재 우리는 컴퓨터 없이는 생활하기 어려운 사회 속에서 살아간다. 컴퓨터를 통해 우리는 어려운 문제를 뚝딱뚝딱 해결할 수 있을 뿐만 아니라, <br>여러가지 엔터테인먼트 요소를 창조해내어 삶에 활력소를 넣기도 한다. 이처럼 겉으로 보기에는 컴퓨터는 만능이다. 해결하지 못하는 문제가 없고,<br>세상 오만가지 일을 다 알 것만 같다. 하지만 과연 그럴까?

언제나 똑똑하기만 할 것 같은 이 컴퓨터도 세상에 풀지 못하는 문제가 있다는 점이 매우 흥미롭다.<br>
그런데 컴퓨터가 문제를 해결하지 못한다는 의미가 무엇일까? 이는 문제해결을 위한 알고리즘이 존재하지 않다는 것이다.

오늘 소개할 '정지문제(halt problem)'는 컴퓨터가 절대 해결할 수 없는 문제(unsolvable problem) 중 하나이다.<br>
정지문제를 해결할 일반적인 알고리즘은 존재하지 않는다는 것을 앨런 튜링이 1936년에 증명을 하였다.

## 정지문제의 의미

#### 프로그램을 설명한 것과 처음 입력값이 주어졌을 때, 이 프로그램에 입력값을 넣고 실행한다면<br> 이 프로그램이 계산을 끝내고 멈출지 아니면 영원히 계속 계산할지 판정하라

쉽게 설명을 하자면 예를 들어, 덧셈연산만 할 수 있는 프로그램에 숫자가 아닌 '그림'을 입력값으로 넣고 실행했을 때<br> 이 프로그램이 과연 계산을 해낼 수 있을 지 또는 무한루프만을 돌릴지 판단하는 **프로그램의 존재 여부**를 묻는 질문이다. 

결론부터 이야기를 하자면, 그러한 프로그램은 존재하지 않는다. 튜링은 이를 귀류법을 통하여 증명을 해냈다.

여기서 **귀류법**이란, 어떤 명제가 참이라는 것을 증명할 때 그 명제의 결론을 부정함으로써<br> 가정이 모순되었음을 보여 간접적으로 그 결론이 성립한다는 것을 증명하는 하나의 방식이다

## 정지문제의 증명

우선 이 프로그램을 H라고 부르고, 이 H는 존재하지 않는다는 것을 증명해야 한다.

귀류법에 따라,<br>
1. 프로그램 H는 존재한다
2. H가 잘못된 결과를 도출해내는 경우를 찾아낸다
3. 전체에 모순되기 때문에, H를 만드는 것은 불가능하다

의 순으로 증명을 해나가면 된다

#### 1. 프로그램 H는 존재한다고 가정한다

H를 구현하는 함수 Halting(A,B)가 있다고 가정한다.<br>
-A: 이 프로그램의 소스코드<br>
-B: A 프로그램에 입력할 입력값

H를 구현하는 Halting(A, B)는 A(B) 가 무한루프로 계산을 하는지 아닌지를 검사하는 프로그램이다.<br>
만약, A(B)가 계산이 가능하다면 true값을 리턴하고, 무한루프를 돌린다면 false값을 리턴하게 될 것이다

이를 파이썬으로 구현해보자


```python
def test(I):
    while I > 0:
        print("The program is stuck!!")
    return 7
```

만약 I=3 이라면, 무한하게 "The program is stuck!!"를 출력해낼 것이고,<br>
     I=-7이라면, 바로 7을 출력해낼 것이다

즉, Halting(test,3)은 False를 리턴하고, 반면 Halting(test, -7)은 True를 리턴하게 된다

위와 같은 경우에는 Halting(A, B)가 정상적으로 작동하는 것을 알 수 있다.

#### 2. H가 잘못된 결과를 도출해내는 경우를 찾아내자

만약, Halting(A, B)가 오류를 도출해내는 함수를 만든다면 어떨까?


```python
def fool(x):
    if Halting(x, x):
        while true:
            print("The program is stuck!!")
    else:
        return 7
```

이 fool 함수의 입력값으로 fool을 넣어서 fool(fool)과 같이 호출한다고 가정하자<br>
그렇다면 Halting(fool, fool)은 어떤 결과를 리턴하게 되는 것일까?

#### 1) Halting(fool, fool)이 true값을 리턴하는 경우

true 값을 리턴한다는 것은 곧 fool(fool)이 무한루프를 돌지 않고 바로 7을 리턴한다는 것이다.<br>
하지만 소스코드와 함께 보면 이는 논리적 오류가 있다는 것을 알 수 있다.<br>

Halting(fool, fool)이 true를 리턴한다면 fool(x) 안에서 while true로 들어가게 된다.<br>
그렇게 된다면 fool(fool)은 무한하게 "The program is stuck!!"를 도출해낼 것이고 이는 곧 무한 루프를 의미한다.<br>
즉, Halting(fool, fool)은 false를 리턴해야 맞다고 할 수 있다.

#### 2) Halting(fool, fool)이 false값을 리턴하는 경우

false 값을 리턴한다고 하면 fool(fool)은 무한 루프를 돈다는 것이다.<br>
하지만 소스코드를 보면 Halting(fool, fool)이 false 라면 else로 진입하여 7을 리턴하고 계산이 끝난다.<br>
즉, 무한 루프를 돌지 않는 것이기 때문에 Halting(fool, fool)은 true를 리턴해야 맞다고 할 수 있다.<br>

#### 3. 이는 전제에 모순을 일으킨다. 

H를 구현하는 것은 불가능 하다는 결론이 나오게 된다.

## 정지문제에 대해 공부하면서...

'이미테이션 게임'이라는 영화를 통해서 앨런 튜링을 처음 알게 되었는데, 그가 독일군의 암호(에니그마)를 해독하는 컴퓨터를 발명함으로써 세계 2차 대전의 종전을 앞당기는 데 일조를 했다는 서사가 매우 흥미로웠었던 기억이 난다. 그의 연구 산물 중 하나인 정지문제를 공부하면서 알쏭달쏭하기도 하고 헷갈리기도 했지만 하나씩 이해해가는 그 과정이 마치 잠긴 문의 열쇠를 찾아 하나씩 열어가는 것처럼 소소한 재미를 느끼게 했던 것 같다. <br>

또한 나에게 컴퓨터란 언제나 만능이며 뭐든지 해낼 수 있는 사물이였었는데, 논리적으로 그렇지 않다는 것을 확인을 하고 보니 거의 23년간 굳게 믿어왔었던 나만의 명제 한가지가 무너지는 것 같아서 아쉽기도 했었다. 지금까지 항상 다소 딱딱한 컴퓨터 지식들만 공부하면서 '대체 이 재미없는 공부가 나에게 무슨 의미가 있는건가'라는 생각을 자주 했었는데 세상에 직접 적용되는 한가지의 논리를 습득하게 되면서 약간의 '소확행'을 얻은 것 같기도 하다. 앞으로 이러한 '소확행'이 자주 수업시간에 등장하면 앞으로 딱딱하고 차갑게 보이기만 하는 이 학문과 조금은 가까워질 수도 있을 것 같다는 생각이 든다.


```python

```
